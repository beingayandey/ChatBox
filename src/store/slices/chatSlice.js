import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { fetchChats } from "../../firebase";

// Thunk to fetch chats for a user asynchronously
// createAsyncThunk simplifies handling async actions in Redux
export const fetchUserChats = createAsyncThunk(
  // Unique action type for this thunk: "chat/fetchUserChats"
  // Used to identify this action in the Redux store
  "chat/fetchUserChats",

  // Async function that takes userId and Redux Toolkit utilities
  // { rejectWithValue } is used to handle errors
  async (userId, { rejectWithValue }) => {
    try {
      // Wrap the fetchChats call in a Promise to handle the real-time listener
      return new Promise((resolve) => {
        // Call fetchChats from the Firebase code
        // fetchChats sets up a real-time listener and returns an unsubscribe function
        const unsubscribe = fetchChats(userId, (chats) => {
          // Process the chats to make them Redux-friendly
          // Firebase timestamps need to be converted to a serializable format
          const serializedChats = chats.map((chat) => ({
            ...chat, // Copy all chat properties
            // Convert Firebase Timestamp to ISO string for Redux
            // Check if lastUpdated exists and is a Firebase Timestamp
            lastUpdated:
              chat.lastUpdated && typeof chat.lastUpdated.toDate === "function"
                ? chat.lastUpdated.toDate().toISOString() // Convert to ISO string
                : null, // Use null if no valid timestamp
          }));

          // Resolve the Promise with the chats and unsubscribe function
          // This becomes the action.payload in the fulfilled case
          resolve({ chats: serializedChats, unsubscribe });
        });
      });
    } catch (error) {
      // If an error occurs, reject with the error message
      // This triggers the rejected case in extraReducers
      return rejectWithValue(error.message);
    }
  }
);

// Create a Redux slice for managing chat state
// A slice combines reducers, actions, and initial state
const chatSlice = createSlice({
  // Name of the slice, used in action types (e.g., "chat/clearChats")
  name: "chat",

  // Initial state of the chat slice
  initialState: {
    chats: [], // Array to store the user's chats
    loading: false, // Tracks if chats are being fetched
    error: null, // Stores any error messages
  },

  // Synchronous reducers for direct state updates
  reducers: {
    // Action to clear all chats
    clearChats: (state) => {
      // Reset the chats array to empty
      state.chats = [];
    },

    // Action to manually set chats
    // Useful for updating chats without fetching
    setChats: (state, action) => {
      // Set chats to the provided payload
      state.chats = action.payload;
      // Reset loading and error states
      state.loading = false;
      state.error = null;
    },
  },

  // Extra reducers for handling async actions (from createAsyncThunk)
  extraReducers: (builder) => {
    builder
      // Handle the "pending" state of fetchUserChats
      // Triggered when the thunk starts fetching
      .addCase(fetchUserChats.pending, (state) => {
        // Set loading to true to show a loading indicator
        state.loading = true;
        // Clear any previous errors
        state.error = null;
      })

      // Handle the "fulfilled" state of fetchUserChats
      // Triggered when the thunk successfully fetches chats
      .addCase(fetchUserChats.fulfilled, (state, action) => {
        // Stop loading
        state.loading = false;
        // Update chats with the fetched chats from action.payload
        // Only store the chats array, not the unsubscribe function
        state.chats = action.payload.chats;
      })

      // Handle the "rejected" state of fetchUserChats
      // Triggered when the thunk fails
      .addCase(fetchUserChats.rejected, (state, action) => {
        // Stop loading
        state.loading = false;
        // Store the error message from the thunk
        state.error = action.payload;
      });
  },
});

// Export the actions generated by the slice
// These can be dispatched to update the state
export const { clearChats, setChats } = chatSlice.actions;

// Export the reducer to include in the Redux store
// This handles all state updates for the chat slice
export default chatSlice.reducer;
